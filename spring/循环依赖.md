# 循环依赖

#### 前置知识 -- 循环依赖在普通的Java SE 中

在spring中，形成这样闭环的依赖情景称为循环依赖。

<img src="../cacheimg/image-20201203214431916.png" alt="image-20201203214431916" style="zoom:50%;" />

1.  构造方法注入，会导致循环依赖的报错，若构造器构造A时，则必须先构造B，而构造B时，又需要构造A，形成类似死锁的死循环。

    <img src="../cacheimg/image-20201203221225016.png" alt="image-20201203221225016" style="zoom: 67%;" />

    <img src="../cacheimg/image-20201203221439353.png" alt="image-20201203221439353" style="zoom:67%;" />

2.  setter方法注入不会导致循环依赖的报错

<img src="../cacheimg/image-20201203221504072.png" alt="image-20201203221504072" style="zoom:67%;" />

<img src="../cacheimg/image-20201203221557190.png" alt="image-20201203221557190" style="zoom:67%;" />

###### 结论：根据上述的原理，说明当构造器注入的方式，在遇到循环依赖时，spring底层无法解决导致报错

------

#### 循环依赖在Spring的容器中

![image-20201203222511681](../cacheimg/image-20201203222511681.png)

###### 重要结论：spring 容器的三级缓存是spring用来解决singleton循环依赖问题的方式，所谓三级缓存即spring容器中的三个map。

<img src="../cacheimg/image-20201203224820212.png" alt="image-20201203224820212" style="zoom:67%;" />

1.  一级缓存

    ```
    singletonObjects
    ```

    用来存放经历完整生命周期初始化好了的bean对象 

2.  二级缓存

    ```
    earlySingletonObjects
    ```

    存放的是实例化了，但是未初始化的Bean

3.  三级缓存

    ```
    singletonFactories
    ```

    存放的是FactoryBean。假如A类实现了FactoryBean,那么依赖注入的时候不是A类，而是A类产生的Bean

##### 单例模式的三级缓存如何解决循环依赖？

1.  A创建过程中需要B，于是A将自己放到三级缓里面，去实例化B
2.  B实例化的时候发现需要A，于是B先查一级缓存，没有，再查二级缓存，还是没有，再查三级缓存，找到了A然后把三级缓存里面的这个A放到二级缓存里面，并删除三级缓存里面的A
3.  B顺利初始化完毕，将自己放到一级缓存里面（此时B里面的A依然是创建中状态)，然后回来接着创建A，此时B已经创建结束，直接从一级缓存里面拿到B，然后完成创建和依赖闭环，并将A自己放到一级缓存里面。

![image-20201219154350886](../cacheimg/image-20201219154350886.png)

###### 结论：Spring解决循环依赖依靠的是Bean的“中间态”这个概念，而这个中间态指的是已经实例化但还没初始化的状态（即半成品，存在2、3级缓存）。实例化的过程是通过构造器创建的，如果A还没创建好出来怎么可能提前曝光，所以构造器的循环依赖无法解决。

**Spring 解决循环依赖流程图**

![image-20201220195040609](../cacheimg/image-20201220195040609.png)

------

#### Spring为什么单例要用三级缓存，只用一级缓存行不行？两级缓存呢？

对于单例而言如果只用singletonObjects一级缓存直接存储已经初始化完毕的bean对象，那么会导致循环引用的问题；若使用二级缓存：earlySingletonObjects+singletonObjects，因为earlySingletonObjects中存储的是实例化但未初始化的对象，因此若AB两个对象互相引用，A只引用B的实例化对象，而B的初始化后置，是可以解决循环引用的问题的，对于循环依赖，事实上使用一、二级缓存或一、三级缓存都是可以解决的，那为什么还要将一、二级缓存区分开来呢？......



**总而言之：**

1.  二级缓存 解决属性字段级别的循环依赖注入问题
2.  三级缓存是为了增强框架的扩展性
3.  对于非单例模式{@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)的bean循环依赖问题依然存在，会抛出循环依赖异常



