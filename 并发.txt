线程的运行机制
	一个CPU每个时刻只能执行一条线程
	操作系统给每条线程分配不同长度的时间片
	操作系统会从一堆线程中随机选取一条来执行
	每条线程用完自己的时间片后，即使任务还没完成，操作系统也会剥夺它的执行权，让另一条线程执行

并发编程需要时刻注意的问题:
	减少上下文切换
	避免死锁(死锁 :体现的是线程之间对对方资源的互相占有导致僵持)
	运行环境资源限制并发

重排序 as if serial 貌似是串行的.

并发编程两大关键问题:
	通信:
		即两条线程之间的消息传递
		两种方式:
			共享内存:
				共享内存指的是多条线程共享同一片内存，发送者将消息写入内存，接收者从内存中读取消息，从而实现了消息的传递。 但这种方式有个弊端，即需要程序员来控制线程的同步，即线程的执行次序。 PS:这种方式并没有真正地实现消息传递，只是从结果上来看就像是将消息从一条线程传递到了另一条线程。

				使用 volatile 关键字于变量 可使变量可见。
				内存可见性:
					指的是一条线程修改完一个共享变量后，另一个线程若访问这个变量将会访问到修改后的值。即：一条线程对共享变量的修改，对其他线程立即可见。
				volatile底层原理，即如何保证共享变量数据可见性:
					底层实现主要是通过汇编lock前缀指令，它会锁定这块内存区域的缓存并会写主内存，即“缓存锁定”，MESI缓存一致性协议（总线嗅探机制）机制会组织同时修改被两个以上处理器缓存的内存区域数据，使各个工作内存指定内容失效，从而再次读取主内存以更新工作内存数据。
				对于共享内存的通信方式，需要进行显示的同步，隐式的通信.
			消息传递:
				顾名思义，消息传递指的是发送线程直接将消息传递给接收线程。 由于执行次序由并发机制完成，因此不需要程序员添加额外的同步机制，但需要声明消息发送和接收的代码。

				对于消息传递的通信方式，需要隐式的同步，显示的通信。

