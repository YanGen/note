
Java 按照是否对资源加锁分为乐观锁和悲观锁 乐观锁悲观锁不是一种被实现的锁 而是两种策略

悲观锁
	认为当前环境非常容易发生碰撞 所以执行操作前需要锁定数据，操作完释放锁，其他操作才能继续操作。
乐观锁
	乐观锁的思想与悲观锁的思想相反，它总认为资源和数据不会被别人所修改，所以读取不会上锁，但是乐观锁在进行写入操作的时候会判断当前数据是否被修改过
	乐观锁的实现方案一般来说有两种：版本号机制 和 CAS实现。乐观锁多适用于多读的应用类型，这样可以提高吞吐量。
	在Java中java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式 CAS 实现的。

两种锁的使用场景
	上面介绍了两种锁的基本概念，并提到了两种锁的适用场景，一般来说，悲观锁不仅会对写操作加锁还会对读操作加锁，一个典型的悲观锁调用：
		select * from student where name="cxuan" for update
	这条 sql 语句从 Student 表中选取 name = "cxuan" 的记录并对其加锁，那么其他写操作再这个事务提交之前都不会对这条数据进行操作，起到了独占和排他的作用。
	悲观锁因为对读写都加锁，所以它的性能比较低，对于现在互联网提倡的三高(高性能、高可用、高并发)来说，悲观锁的实现用的越来越少了

	相对而言，乐观锁用于读多写少的情况，即很少发生冲突的场景，这样可以省去锁的开销，增加系统的吞吐量。
		