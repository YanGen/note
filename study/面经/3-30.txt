一、synchronized 和 lock 的区别
	1.lock是接口而synchronized 是关键字。
	2.synchronized在遇到异常或者执行完成同步块中内容后会自动释放锁，而lock 需要主动释放。
	3.synchronized 底层实现而lock作为一个类通过线程调度实现。
	4.synchronized 无法获得锁状态而lock可以。

二、JVM调优基本思路
	如果CPU用率较高，GC频繁且GC时间长，可能就需要JVM调优了。基本思路就是让每一次GC都回收尽可能多的对象，可以先采用JVM的默认值，然后通过压测分析GC日志。

	如果看年轻代的内存使用率处在高位，导致频繁的Minor GC，而频繁GC的效率又不高，说明对象没那么快能被回收，这时年轻代可以适当调大一点。

	如果看年老代的内存使用率处在高位，导致频繁的Full GC，这样分两种情况：如果每次Full GC后年老代的内存占用率没有下来，可以怀疑是内存泄漏；如果Full GC后年老代的内存占用率下来了，说明不是内存泄漏，要考虑调大年老代。

三、volatile底层原理，即如何保证共享变量数据可见性:
	底层实现主要是通过汇编lock前缀指令，它会锁定这块内存区域的缓存并会写主内存，即“缓存锁定”，MESI缓存一致性协议（总线嗅探机制）机制会组织同时修改被两个以上处理器缓存的内存区域数据，使各个工作内存指定内容失效，从而再次读取主内存以更新工作内存数据。

四、锁的种类
	1.基于执行公平性，分为公平锁（队列排队）/非公平锁（竞争）
	2.根据某线程是否可重复获取锁分为可/不可重入锁
	3.互斥锁/读写锁 （广义上称共享+排他锁），对读操作共享对写操作排他
	4.乐观锁/悲观锁
		乐观锁就是乐观的认为不会发生冲突，用cas和版本号实现
		悲观锁就是认为一定会发生冲突，对操作上锁
	5.分布式锁
	6.分段锁
	7.自旋锁

五、CAS 硬件级别保证原子性，如何实现？过程？
	1.预设 内存值、预期值、新值 三个值
	2.进行 预期值和内存值 是否相等的判断
	3.若相等则修改内存值为新值
	4.若不相等则更新 预期值和新值 
	5.重复以上操作直到修改成功 结束

六、http 请求过程 访问 baidu.com为例
	1.首先向DNS寻求域名对应ip地址
	2.生成针对服务器的Http报文，随后向底层协议进行包装
	3.逐次包装TCP首部（传输层）、IP首部（网络层）、以太网首部（链路层），最后转化比特流（物理层）后传输
	4.其中TCP的职责是经过三次握手，成功后形成链接会话，保证链接可靠，此外为了方便通信，会将Http请求报文分割成报文段，一段一段的进行传输，在接受方接受到Http报文段后按序号进行重组；ip协议的职责是搜索传输地址，一边中转一边传输；
	5.服务端接受的数据包后又反向解除各层协议的包装（以太网协议->...->http协议包）解读请求的内容，将请求结果又封装成Http协议的数据包，按上述的过程返回
