一、synchronized 和 lock 的区别
	1.lock是接口而synchronized 是关键字。
	2.synchronized在遇到异常或者执行完成同步块中内容后会自动释放锁，而lock 需要主动释放。
	3.synchronized 底层实现而lock作为一个类通过线程调度实现。
	4.synchronized 无法获得锁状态而lock可以。

二、JVM调优基本思路
	如果CPU用率较高，GC频繁且GC时间长，可能就需要JVM调优了。基本思路就是让每一次GC都回收尽可能多的对象，可以先采用JVM的默认值，然后通过压测分析GC日志。

	如果看年轻代的内存使用率处在高位，导致频繁的Minor GC，而频繁GC的效率又不高，说明对象没那么快能被回收，这时年轻代可以适当调大一点。

	如果看年老代的内存使用率处在高位，导致频繁的Full GC，这样分两种情况：如果每次Full GC后年老代的内存占用率没有下来，可以怀疑是内存泄漏；如果Full GC后年老代的内存占用率下来了，说明不是内存泄漏，要考虑调大年老代。

三、volatile底层原理，即如何保证共享变量数据可见性:
	底层实现主要是通过汇编lock前缀指令，它会锁定这块内存区域的缓存并会写主内存，即“缓存锁定”，MESI缓存一致性协议（总线嗅探机制）机制会组织同时修改被两个以上处理器缓存的内存区域数据，使各个工作内存指定内容失效，从而再次读取主内存以更新工作内存数据。

四、锁的种类
	1.基于执行公平性，分为公平锁（队列排队）/非公平锁（竞争）
	2.根据某线程是否可重复获取锁分为可/不可重入锁
	3.互斥锁/读写锁 （广义上称共享+排他锁），对读操作共享对写操作排他
	4.乐观锁/悲观锁
		乐观锁就是乐观的认为不会发生冲突，用cas和版本号实现
		悲观锁就是认为一定会发生冲突，对操作上锁
	5.分布式锁
	6.分段锁
	7.自旋锁

五、CAS 硬件级别保证原子性，如何实现？过程？
	1.预设 内存值、预期值、新值 三个值
	2.进行 预期值和内存值 是否相等的判断
	3.若相等则修改内存值为新值
	4.若不相等则更新 预期值和新值 
	5.重复以上操作直到修改成功 结束

六、http 请求过程 访问 baidu.com为例
	1.首先向DNS寻求域名对应ip地址
	2.生成针对服务器的Http报文，随后向底层协议进行包装
	3.逐次包装TCP首部（传输层）、IP首部（网络层）、以太网首部（链路层），最后转化比特流（物理层）后传输
	4.其中TCP的职责是经过三次握手，成功后形成链接会话，保证链接可靠，此外为了方便通信，会将Http请求报文分割成报文段，一段一段的进行传输，在接受方接受到Http报文段后按序号进行重组；ip协议的职责是搜索传输地址，一边中转一边传输；
	5.服务端接受的数据包后又反向解除各层协议的包装（以太网协议->...->http协议包）解读请求的内容，将请求结果又封装成Http协议的数据包，按上述的过程返回

七、TCP为什么要握手？为什么是三次握手？两次可以吗？四次挥手，为什么是四次？
	1.对比TCP和UDP会发现TCP 与 UDP 的一个基本区别，既TCP是可靠通信协议，而 UDP 是不可靠通信协议。TCP 的可靠性是因为经过握手保证接收方收到的数据是完整，有序，无差错的。UDP 不可靠性因为在 UDP 协议中是没有握手这个操作的，接收方接收到的数据可能存在部分丢失， 顺序也不一定能保证。
	2.TCP 协议为了实现可靠传输， 通信双方需要判断自己已经发送的数据包是否都被接收方收到， 如果没收到， 就需要重发。 为了实现这个需求， 很自然地就会引出序号（sequence number） 和 确认号（acknowledgement number） 的使用，这样发送方就可以知道哪些数据被接收到，哪些数据没被接收到， 需要重发。
	3.两次握手无法保证链接的可靠，需要三次握手的最重要的原因是TCP是双向可靠链接（全双工），为了保证TCP链接双方收发正常和序列号同步，假设A像B发送一个序列号此时B需要返回一个确认收以确定A向B建立的TCP建立的单向发送过程同步无误，那么B向A同样需要建立单向链接从而构成双向链接，那么在第一次握手后B向A发送的确认号同时填补一个B向A链接的序列号，同理后续A向B返回确认号，总共三次握手为最少握手次数。
	4.建立连接时的三次握手中第二次的SYN和ACK一起发送，但在四次挥手的时候没有将FIN和ACK一起发送呢，所以需要四次（具体原因就不追了）。