pring-cloud的服务调用是基于http调用，dubbo是基于RPC调用。使用feign就能实现微服务间的方法调用。其实本质上相当于前端调用http接口,只不过这里用java代码实现，但也因此, 使用feign就可以与其他语言进行http通信了， 就是需要多一步写接口的流程。

spring-cloud的服务调用一般有两种，第一种是ribbon+restTemplate，第二种是feign 

下面记录feign 使用中遇到的坑
1.	@RequestMapping(value = "/user/{id}", method = RequestMethod.GET) 
	@GetMapping("/user/{id}")

	这两个注解的效果是等价的，但是在Feign使用中，只能用上面的那种方式，不能直接用@GetMapping，下面我们将前面的那个示例中，改成@GetMapping注解看下效果，我们发现，修改注解后重新启动服务的时候，抛了如下异常：
	Caused by: java.lang.IllegalStateException: Method findById not annotated with HTTP method type (ex. GET, POST) 
	异常的意思是，我们没有指定HTTP的方法
2.	@GetMapping("/template/{id}") 
	public User findById(@PathVariable Long id) { 
	return client.findById(id); 
	}

	这里，findById方法的参数中，我们直接使用了

	@PathVariable Long id

	启动服务，我们发现，又抛异常了，异常信息如下：

	Caused by: java.lang.IllegalStateException: PathVariable annotation was empty on param 0. 

	大概的意思是PathVariable注解的第一个参数不能为空，我们改成如下的方式：

	@RequestMapping(value = "/user/{id}", method = RequestMethod.GET) 
	User findById(@PathVariable("id") Long id);

3.	当接口上配了 FeignClient 和 RequestMapping 两个注解

	@FeignClient(value = "MICROSERVICECLOUD-GOODS-PROVIDER-8004",fallbackFactory=GoodsClientServiceFallbackFactory.class)
	@RequestMapping("/goods")
	public interface GoodsClientService extends BaseServiceApi<Goods> {

	}

	报
	This application has no explicit mapping for /error, so you are seeing this as a fallback.

	改
	@FeignClient(value = "MICROSERVICECLOUD-GOODS-PROVIDER-8004",path = "/goods",fallbackFactory=GoodsClientServiceFallbackFactory.class)
	public interface GoodsClientService extends BaseServiceApi<Goods> {

	}
