累加载子系统加载过程
	1.加载 
		通过一个类的全限定名获取类的二进制文件流，在内存中生成一个代表这个类的java.lang.Class 对象。
			ps:对每一种对象，JVM 都会实例化一个 java.lang.Class 的实例，java.lang.Class 为我们提供了在运行时访问对象的属性和类型信息的能力。
		a.引导类加载器（Bootsrap ClassLoader） -- C/C++实现 嵌套JVM内部 非自定义
			用于加载Java中的核心类库，核心类库包括扩展类加载器和系统类加载器。
			出于安全考虑，只加载包名为java、javax、sun等部分开头的类。

		b.扩展类加载器（Extension ClassLoader） -- Java实现 JVM自带 Java系统自定义
			用于从扩展目录中加载类库，用户可根据需要将jar包至于扩展目录下。
		c.系统/应用程序 类加载器（System/App ClassLoader） -- Java实现 JVM自带 Java系统自定义
			负责加载classpath或其他系统属性
			通过ClassLoader#getSystemClassLoader
		d.用户自定义加载器（User Defind ClassLoader） -- Java实现 个体用户自定义
			为什么要自定义：
				1.隔离加载类 2.修改加载过程（防止被反编译泄露源码）3.扩展加载源

		四者非继承关系，而是包含关系（可通过getParent拿到），扩展类加载器、系统类加载器和用户自定义加载器继承于一个基类 ClassLoader。

	2.链接
		a.验证（verify）
			验证二进制文件安全，确保虚拟机不被恶意攻击，包括文件格式验证，原数据验证，字节码验证，符号引用验证。
		b.准备（Prepare）
			为类变量赋默认初始值，比如整型赋零值。
			不包含final修饰static常量，因为final编译的时候就会分配
		c.解析（解析）
	3.初始化 
		初始化阶段就是执行类构造器方法<clinit>()的过程
			clinit无需定义，是javac编译器自动收集类中所有变量的赋值动作和静态代码块的语句合并而来的
		若该类拥有父类则先加载父类的<clinit>()
		虚拟机执行<clinit>()方法在多线程下被同步加锁

双亲委派机制
	定义:Java虚拟机对class文件采用的是按需加载的方式，也就是当需要使用该类的时候才会将其class文件加载至内存生成class对象。加载某个类的class文件时，Java虚拟机采用的是双亲委派机制，即把请求交由父类处理，是一种任务委派模式。
	原理（见图）：
		简单一句话，类的加载器收到类加载的请求，会先向上层委托加载（parent classloader），如果上层加载器无法完成加载任务，当前加载器才会尝试加载。
	作用：
		双亲委派机制使得属于上层的类无法被篡改，如核心类String一定会委派给引导类加载器加载，而在引导类加载器成功加载后，处于下层的加载器无法再加载，自然不会加载自己定义的String。
		双亲委派机制是Java沙箱安全机制的组成部分。

