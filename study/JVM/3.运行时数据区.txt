1.pc寄存器（每个线程拥有）
	作用：用来存储下一条指令地址，也即 将要执行的指令地址，由执行引擎读取下一条指令。如此一来，jvm内部进行线程切换时就可以在pc寄存器中读取指令的断点，继续执行。

	为什么pc寄存器每条线程一份？
		因为每条线程都需要记录下一条指令地址
		
2.虚拟机栈（每个线程拥有）
	内部保存一个个的栈帧，一个栈帧对应一个Java方法，一个方法的执行对应着一个栈帧的入栈，一个方法执行结束对应着栈帧出栈。
	栈帧主要保存局部变量（8种基本数据类型和对象引用）、部分结果，因存储内容量轻所以不会有垃圾回收的问题（GC）但存在溢出的可能（OOM）。
	生命周期和线程一致。

	通过 -Xss可以调整虚拟机栈初始大小。

	栈帧内部结构：
		1.局部变量表（Local Variables ,简称LV）
			“表”为一维数组，主要存储方法参数和定义在方法体内部的局部变量，局部变量表容量在前期编译时确定。

			局部变量表最基本的存储单元是slot(变量槽)
			基本数据类型+引用 除了long 和 double需两个槽位外 均需一个槽位。

			局部变量表中的引用是重要的垃圾回收根节点，只要被局部变量表中直接或间接的引用的对象都不会被回收。

		2.操作数栈（Operand Stack），或称表达式栈
			用于保存计算过程的中间结果，作为临时储存空间。

			ps：同局部变量表的是，基本数据类型+引用 除了long 和 double需两个栈位外 均需一个栈位。

		3.动态链接（Dynamic Linking），或称指向运行时常量的方法引用
			动态链接的作用是将 #1、#2、#3（字节码指令） 的这些符号引用转换为调用方法的直接引用。

			ps:
				静态链接（前期绑定）：当一个字节码文件被装载进JVM内部时，如果被调用的目标方法在 编译时期 可知（非虚方法），且运行时保持不变。这种情况下将调用方法的符号引用转换为直接引用的过程为静态链接。

				动态链接（晚期绑定）：编译时期无法被确定下来（虚方法），也就是说，只能在运行期间将调用方法的符号引用转换为直接引用，而引用具有动态行为动态链接。

				区别在于编译时期确定和运行时期确定。

				非虚方法有三种:

					 1、由invokestatic指令调用的static方法，这种方法在编译时确定在运行时不会改变。

					 2、由invokespecial指令调用的方法，这些方法包括私有方法，实例构造方法和父类方法，这些方法也是在编译时已经确定，在运行时不会再改变的方法

					 3、由final关键字修饰的方法。虽然final方法是由invokevirtual指令进行调用的，但是final修饰的方法不能够进行在子类中进行覆盖，所有final修饰的方法是不能够在运行期进行动态改变的。在java语言规范中明确规定final方法就是非虚方法。

				关于invokedynamic:
					JDK8后引入,是为了Java实现 “动态类型语言”支持而做的改进



		4.方法返回地址（Return Address），或方法正常、异常退出指向
			方法退出两种方式：正常执行结束和出现未处理的异常。
			无论以哪种方式退出，都需要回到原调用此方法的调用位置，而方法返回地址记录调用者的pc计数器的值，即调用该方法的指令的下一条指令。

			方法返回指令：
				ireturn boolean 、byte、char、short和int
				lreturn freturn dreturn
				areturn 对象引用返回
				return void、实例初始化方法、类和接口的初始化方法

		5.一些附加信息
	常见异常：
		SOF：栈溢出，即栈大小超出限制 OOM：内存溢出	，即在申请内存时超出
3.本地方法栈（每个线程拥有）
	本地方法栈与虚拟机栈类似，区别在于本地方法栈管理本地方法的调度，和本地方法接口交互。

4.堆
	《Java 虚拟机规范》规定，堆可以在物理上不联系，但在逻辑上应该被视为连续的。
	“几乎”所有对象实例和数组都在堆分配内存。

	通过 -XX:+PrintGCDetails 显示垃圾回收细节
	通过 -Xms 设置堆区初始化内存
	通过 -Xmx 设置堆区最大内存
	通过 -Xmn 设置新生代的空间大小(和下面设置 新老比例参数冲突 一般不设置)
	通过 -XX:NewRatio 设置新生代和老年代大小比例 默认1：2(一般不改)
	通过 -XX:SurvivorRatio 设置伊甸园区和 S1+S2 的比例 默认8:1:1

	堆分区
		新生代 PSYoungGen
			伊甸园 eden
			幸存1区 from
			幸存2区 to
		老年代 ParOldGen
		元空间 MetaSpace (ps:jdk7到8内存结构主要变化是 永久代->元空间)

	GC garbage collect（STW stop the world）
		Partial GC 部分收集
			Minor GC/Young GC 新生代收集(Eden/S1/S2)
				Eden满触发
			Major GC/Old GC 老年代收集(Old)
			Miexd GC 混合GC
		Full GC 整堆收集(方法区和Java 堆)




	TLAB Thread Local Allocation Buffer 
		即线程本地分配缓存区，这是一个在伊甸园中、线程专用的内存分配区域。TLAB空间的内存非常小，缺省情况下仅占有整个Eden空间的1%。

		New对象与指针碰撞
			堆空间是数据共享区域，如果实例对象时同时申请一块地址则产生碰撞。

		TLAB 分配
			线程创建对象优先在本TLAB区分配空间，如果不成功则在Eden其他区域进行加锁分配。
	通过 -XX:+PrintFlagsInitial 查看所有参数的默认初始值
	通过 -XX:+PrintFlagsFinal 查看所有参数的最终值
		具体查看某个参数的指令
			jps 查看当前运行的进程
			jinfo -flag SurvivorRatio 进程id

	对象一定在堆上分配吗？
		编译器再编译期根据逃逸分析结果，如果经过逃逸分析后一个对象并没有逃逸出方法的话，那么就可能被优化成在栈上分配。这样就无需再堆上分配内存，也无须进行垃圾回收。

		-XX:+DoEscapeAnalysis 开启逃逸分析 默认开启
		-XX:+EliminateLocks 开启同步消除 默认开启
		-XX:+EliminateAllocations 开启标量替换 默认开启

		虚拟机逃逸分析机制带来的代码优化 (逃逸分析如今仍不成熟)
			栈上分配
				使对象不发生逃逸，从而堆分配转栈分配。
			同步省略（锁消除）
				一个对象被分析只能从一条线程中被访问，则对于这个对象的所有操作不同步。
				同步省略时在运行时省略而非编译期，例如使用synchronized加锁编译后，在字节码指令中仍能看到 monitorenter monitorexit。
			标量替换（变形栈上分配）
				标量(scalar):指一个无法再分解成更小数据的数据，Java中原始数据类型就是标量。
				聚合量(Aggregate):指Java对象。
				对象可以分解成其他聚合量和标量，若经过逃逸分析发现这个对象未逃逸，则把这个对象肢解成若干标量来代替，即标量替换。
				例如：
					User{int id;String name;}

					void method(){
						User user = new User(1,"name");
					}
					user 可以被肢解成标量存储在局部变量表中。



