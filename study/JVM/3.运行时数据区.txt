1.pc寄存器（每个线程拥有）
	作用：用来存储下一条指令地址，也即 将要执行的指令地址，由执行引擎读取下一条指令。如此一来，jvm内部进行线程切换时就可以在pc寄存器中读取指令的断点，继续执行。

	为什么pc寄存器每条线程一份？
		因为每条线程都需要记录下一条指令地址
		
2.虚拟机栈（每个线程拥有）
	内部保存一个个的栈帧，一个栈帧对应一个Java方法，一个方法的执行对应着一个栈帧的入栈，一个方法执行结束对应着栈帧出栈。
	栈帧主要保存局部变量（8种基本数据类型和对象引用）、部分结果，因存储内容量轻所以不会有垃圾回收的问题（GC）但存在溢出的可能（OOM）。
	生命周期和线程一致。

	通过 -Xss可以调整虚拟机栈初始大小。

	栈帧内部结构：
		1.局部变量表（Local Variables ,简称LV）
			“表”为一维数组，主要存储方法参数和定义在方法体内部的局部变量，局部变量表容量在前期编译时确定。

			局部变量表最基本的存储单元是slot(变量槽)
			基本数据类型+引用 除了long 和 double需两个槽位外 均需一个槽位。

			局部变量表中的引用是重要的垃圾回收根节点，只要被局部变量表中直接或间接的引用的对象都不会被回收。

		2.操作数栈（Operand Stack），或称表达式栈
			用于保存计算过程的中间结果，作为临时储存空间。

			ps：同局部变量表的是，基本数据类型+引用 除了long 和 double需两个栈位外 均需一个栈位。

		3.动态链接（Dynamic Linking），或称指向运行时常量的方法引用
			动态链接的作用是将 #1、#2、#3（字节码指令） 的这些符号引用转换为调用方法的直接引用。

			ps:
				静态链接（前期绑定）：当一个字节码文件被装载进JVM内部时，如果被调用的目标方法在 编译时期 可知（非虚方法），且运行时保持不变。这种情况下将调用方法的符号引用转换为直接引用的过程为静态链接。

				动态链接（晚期绑定）：编译时期无法被确定下来（虚方法），也就是说，只能在运行期间将调用方法的符号引用转换为直接引用，而引用具有动态行为动态链接。

				区别在于编译时期确定和运行时期确定。

				非虚方法有三种:

					 1、由invokestatic指令调用的static方法，这种方法在编译时确定在运行时不会改变。

					 2、由invokespecial指令调用的方法，这些方法包括私有方法，实例构造方法和父类方法，这些方法也是在编译时已经确定，在运行时不会再改变的方法

					 3、由final关键字修饰的方法。虽然final方法是由invokevirtual指令进行调用的，但是final修饰的方法不能够进行在子类中进行覆盖，所有final修饰的方法是不能够在运行期进行动态改变的。在java语言规范中明确规定final方法就是非虚方法。

				关于invokedynamic:
					JDK8后引入,是为了Java实现 “动态类型语言”支持而做的改进



		4.方法返回地址（Return Address），或方法正常、异常退出指向
		5.一些附加信息
		
