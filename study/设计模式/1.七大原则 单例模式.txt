	接口是方法的抽象 而抽象类是对象的抽象
	核心：所有原则实际围绕降低各方的耦合

一、七大原则
	1.开闭原则（Open Closed Principle，OCP）
		最基础、最重要的设计原则
		对未有的进行扩展开放，对原有的修改关闭

	2.单一职责原则（Single Responsibility Principle, SRP）
		职责单一降低复杂度
	3.里氏代换原则（Liskov Substitution Principle，LSP）
		继承父类实际上会带来父子类的耦合度增强，子类尽量不要重新父类的方法，而继承父类最好继承“抽象”类，设想较为Base父类，子类就不必重写父类方法，换句话说Base类是所有子类存在的通用方法，若有不同就不要写进去了
	4.依赖倒转原则（Dependency Inversion Principle，DIP）
		1）高层不应该依赖底层，细节应该以来抽象
		2）理念：相对于细节的事物总是多变，而抽象则趋于稳定
		3）依赖传递的三种方式：接口传递、构造方法传递和setter传递

	5.接口隔离原则（Interface Segregation Principle，ISP）
		别浪费原则
	6.合成（组合）/聚合复用原则（Composite/Aggregate Reuse Principle，CARP）
		一句话，尽量使用合成/聚合的方式而非继承

	7.最少知识原则（Least Knowledge Principle，LKP）或者迪米特法则（Law of Demeter，LOD）
		封装好自己的逻辑，虽然类与类的依赖不可避免，但对其他类中各个属性等内容知道的越少越好

二、单例模式
	1.饿汉式（静态常量）[可用]
		public class Singleton {
		    private final static Singleton INSTANCE = new Singleton();
		    private Singleton(){}
		    public static Singleton getInstance(){
		        return INSTANCE;
		    }
		}
	2.饿汉式（静态代码块）[可用]
		public class Singleton {
		    private static Singleton instance;
		    static {
		        instance = new Singleton();
		    }
		    private Singleton() {}
		    public static Singleton getInstance() {
		        return instance;
		    }
		}
	6.双重检查[线程安全、无效率问题]
		public class Singleton {
		    private static volatile Singleton singleton;
		    private Singleton() {}
		    public static Singleton getInstance() {
		        if (singleton == null) {
		            synchronized (Singleton.class) {
		                if (singleton == null) {
		                    singleton = new Singleton();
		                }
		            }
		        }
		        return singleton;
		    }
		}
	7.静态内部类
		// 静态内部类会等到使用实才实例而且保证实例时线程安全
		public class Singleton {
		    private Singleton() {}
		    private static class SingletonInstance {
		        private static final Singleton INSTANCE = new Singleton();
		    }
		    public static Singleton getInstance() {
		        return SingletonInstance.INSTANCE;
		    }
		}
	8.枚举
		public enum Singleton {
		    INSTANCE;
		    public void whateverMethod() {
		    }
		}