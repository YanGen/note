
垃圾：
	没有被引用到的就是垃圾

判断对象是否垃圾：
	引用计数算法和可达性分析算法

	引用计数算法
		当一个对象被引用时它的引用计数+1 ，当引用失效时计数-1，当计数为0时它就是个垃圾。
		优点：简单，判断效率高，回收无延迟。
		缺点：
			需要单独字段存储，增加空间开销。
			每次更新都伴随着运算，增加时间开销。
			无法处理循环引用,即对象引用链（致命）
		ps
			Java不使用引用计数，Python使用。
 	可达性分析算法
 		GC Roots，引用链根部无法到达的对象为垃圾。
 		GC Roots GC根 包括
 			虚拟机栈中引用的对象
 			同步锁持有的对象
 			虚拟机内部对象，比如基本数据类型对于的Class对象，一些常驻的异常对象等

对象的 finalization 机制
	对象销毁时，提供对象销毁前自定义的处理逻辑，finalized方法。

	注意
		方法中可令对象复活。
		不要主动调用此方法，应交给垃圾回收机制调用。

垃圾清除算法
	标记-清楚(Mark-Sweep)算法 1960年
		标记：从根节点出发遍历标记可达对象，标记非垃圾对象，标记在对象头
		清除：清楚不被标记的对象

		优点：
			基础
		缺点：
			效率不算高(遍历)
			STW
			产生内存碎片，需要维护一个内存空闲列表
	复制(Copying)算法 1963年
		ps 新生代 From区到To区 使用此算法
		核心思想
			内存分两块，每次使用其中一块，垃圾回收时正在使用的内存中可达对象复制并且紧凑的排列再另一块空间，剩下不可达对象可完全清除，下次回收依旧如此。
		优点：
			没有标记-清除的过程，实现简单，运行高效
			复制过去保证空间连续，不会有内存碎片
		缺点：
			需要两倍空间
			复制后需要维护原引用指向地址
			(特别)系统中如果对象存活率太高，则每次复制需要迁移的对象非常多，导致效率标的
			ps 新生代对象朝生夕死，S1 S2分区使用此算法非常理想，老年代对象持久则不适合。
			STW
	标记-压缩(标记整理、Mark-Compact)算法 1970年
		标记：从根节点出发遍历标记可达对象，标记非垃圾对象，标记在对象头
		压缩：进行存活对象整理，填补到前方内存碎片中，形成相对连续的空间。
		优点：
			解决了标记清除算法的内存碎片问题
			解决了复制算法的空间分区内存减半的代价
		缺点：
			效率上，此算法低于复制算法，同样需要维护存活对象原引用指向地址
			STW
	结论：没有最优算法，只有最适合的算法。

	分代收集思想
		根据不同分代的特点结合合适的算法，目前几乎所有GC都是采用分代收集的算法执行垃圾回收。
		年轻代
			空间较小，对象生命周期段、存活率低，回收频繁，适合复制算法。
		老年代
			空间大，对象生命周期长，存活率高，回收不频繁，标记清除和标记整理结合使用。

	增量收集算法
		基本思想
			每次垃圾收集线程只收集一小片区域，接着切换回应用线程，依次反复，直到垃圾收集完成。
		优点：
			间接性垃圾收集能减少停顿时间。
		缺点：
			线程切换增加了线程切换上下文转换的消耗，增加垃圾回收成本，造成系统吞吐量下降。
注意：
	上述都是基本算法思路，实际GC实现过程要复杂的多，而且会杂糅着使用，并发和并行兼备。

主动垃圾回收
	System.gc() 既Runtime.getRuntime().gc()
		主动触发full gc 不一定能马上执行
	System.runFinalization();
		马上执行，强制调用失去引用的对象的finalized()方法
 
内存溢出 OOM
	1堆内存设置不够
	2创建大量大对象且长时间不能回收
内存泄漏
	存在对象没有被引用但GC时没有被回收，此时称为内存泄漏。
	一些提供close的资源链接对象没有手动close也会导致泄漏。
	宽泛意义上的内存泄漏
		对象虽然被引用但长时间或过程中基本不使用，不能被回收，比如某静态成员变量，随类产生和消亡，如果未使用则会长时间占据空间，大量存在则可能导致内存溢出。

STW stop the world
	GC时，整个应用线程(用户线程)会在安全点或安全区域挂起，线程切换为垃圾回收线程，所以用户线程不会有任何反应
	为什么垃圾回收要停止用户线程？
		垃圾回收涉及对象(内存)迁移、回收，必须停止等待整个过程的完成。

	安全点和安全区域
		程序运行，不是每个时刻都能停下，只有在特定位置才能停下来GC。
		安全点和区域指某个运行点或运行片段上，对象引用关系不会发生变化，在这个区域中GC是安全的。

引用 强度依次递减
	强引用 可达，不回收
		Object obj = new Object()
		只要强引用关系存在，垃圾收集器永远不会回收该对象。
	软引用 可达，不足回收
		空间不足时(溢出前)，将会把这些对象列入回收范围之内进行二次回收，此次回收后空间仍然不够存放新对象则OOM。
	弱引用 可达，发现既回收
		无论空间是否足够，只能生存到下一次垃圾回收之前。
	虚引用 不可达，对象回收跟踪
		无法通过引用获得实例,主要用于对象回收跟踪和通知。

垃圾回收器 GC garbage collector
	评价GC性能指标(两大指标)
		吞吐量:运行用
		户代码的时间占总运行时间比例
		暂停时间(延迟)：GC时间
	7款经典垃圾收集器
		串行回收：Serial、Serial Old
		并行回收：ParNew、Paeallel Scavenge、Parallel Old
		并发回收：CMS、G1

		ps:根据需要场景不同，而选择不同垃圾收集器及收集器组合。

	Serial 新生代、Serial Old老年代
		若限定于单核CPU，优势简单而高效
		设置 -XX:+UseSerialGC
		使用场景
			最小化使用内存和开销

	ParNew 新生代
		-XX:+UseParNewGC 设置
		-XX:+ParallelGCThreads 设置线程数量

	Paeallel 新生代
		-XX:+UseParallelGC
	Paeallel Old 老年代
		-XX:+UseParallelOldGC
		Paeallel吞吐量优先，自适应调节策略
		使用场景
			最大化吞吐量
	
	CMS Concurrent-Mark-Sweep 并发-标记-清除 老年代收集器
		回收线程与用户线程同时工作，关注GC暂停时间、低延迟优先
		没有空间碎片
		使用场景
			最小化暂停时间

	G1 Garbage First 垃圾优先
		特点
			并行与并发兼具
			分代收集
				G1仍然是分代型垃圾回收器，但他把空间划分为多个region，region可以充当Eden、Survivor、Old...逻辑上包含新老年代，但空间上不连续。
			空间整合
				G1 Region之间是复制算法，但从整体上可看作标记压缩，不会有空间碎片
			可预测的停顿时间模型
		比较重要的参数
			-XX: +UseG1GC JDK8及之前需要显示声明、JDK9之后为默认收集器
			-XX:G1HeapRegionSize 每个region大小 默认内存1/2000
			-XX:ConcGCThreads 并发标记线程数
		使用场景:
			针对具有低延迟、大内存、多处理器的机器。(普通大小的堆表现平平)

		region分区
			化整为零，跳出原先的模式局限，现在的互联网项目一般用G1
GC日志分析
	日志打印
		-XX:+PrintGC 输出日志信息
		-XX:+PrintGCDetails
		-XX:+PrintGCTimeStamps GC的时间戳
		-XX:+PrintGCDateStamps GC的时间戳
	GC查看工具
		GCViwer、GCEasy 等

未来
	ZGC 实验性阶段
	未来实现可并发的标记-压缩算法，一旦并发就可以解决STW(非百分百解决)，已低延迟为首要目标