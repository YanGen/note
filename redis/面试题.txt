Redis的全称是 Remote Dictionary Server。

Redis设置密码及验证密码
	设置密码：config set requirepass 123456
	授权密码：auth 123456

1、什么是Redis？简述它的优缺点？

	Redis本质上是一个Key-Value类型的内存数据库，整个数据库统统加载在内存当中进行操作，定期通过异步操作把数据库数据flush到硬盘上进行保存。

	因为是纯内存操作，就决定了它用非常出色的性能，单个value的最大限制是1GB、一个字符串类型的值能存储最大容量是512M
	而其主要缺点是容易受到物理内存的限制，不能作为海量数据的高性能读写，因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。

2.如何保证redis中存放的都是热点数据？
	场景：MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据？
	当redis使用的内存超过了设置的最大内存时，会触发redis的key淘汰机制。限定 Redis 占用的内存，Redis 会根据自身数据淘汰策略，留下热数据到内存。所以，计算一下 20w 数据大约占用的内存，然后设置一下 Redis 内存限制即可。

3.Redis有哪几种数据淘汰策略？

	noeviction:返回错误当内存限制达到并且客户端尝试执行会让更多内存被使用的命令（大部分的写入指令，但DEL和几个例外）
	allkeys-lru: 尝试回收最少使用的键（LRU），使得新添加的数据有空间存放。
	volatile-lru: 尝试回收最少使用的键（LRU），但仅限于在过期集合的键,使得新添加的数据有空间存放。
	allkeys-random: 回收随机的键使得新添加的数据有空间存放。
	volatile-random: 回收随机的键使得新添加的数据有空间存放，但仅限于在过期集合的键。
	volatile-ttl: 回收在过期集合的键，并且优先回收存活时间（time to live,TTL）较短，既删除剩余时间最短的键,使得新添加的数据有空间存放。

4.为什么Redis需要把所有数据放到内存中？
	为了高速读写，如果不将数据放在内存中，磁盘I/O速度为严重影响redis的性能。在内存越来越便宜的今天，redis将会越来越受欢迎。

5.Redis 适用场景？
	会话缓存（Session Cache）
	队列
	发布/订阅

6.Redis哈希槽的概念？什么是一致性hash？

	Redis每个key通过CRC16校验后对总槽位数取模来决定放置哪个槽，集群的每个节点负责一部分hash槽。
	普通的余数hash（hash(比如用户id)%服务器机器数）算法伸缩性很差，当新增或者下线服务器机器时候，用户id与服务器的映射关系会大量失效。一致性Hash可以解决这个问题。一致性hash将原本根据机器数取模改成对2^32取模，则1到2^32次方会形成一个hash环，根据ip将服务器哈希到环上固定位置，后面的ObjectKey哈希落位经过顺时针寻址得到顺时针方向邻近的服务器。此时新增、删除、宕机只会有一条机器被波及需要调整。
	详见 www.baidu.com 图见 一致性hash.jpg

7.Redis集群的主从复制模型是怎样的？

	为了使在部分节点失败或者大部分节点无法通信的情况下集群仍然可用，所以集群使用了主从复制模型,每个节点都会有N-1个复制品.

8.Redis集群方案应该怎么做？都有哪些方案？
	codis。
	redis cluster3.0自带的集群。
	起几个毫无关联的redis实例,业务代码层实现哈希分发。

9.redis 单线程模型为什么快？
	1.单线程不会在加锁和线程切换产生消耗。
	2.redis 采用网络IO多路复用技术来保证在多连接的时候，系统的高吞吐量。

10.CPU 是redis瓶颈所在吗？

	redis既是单线程模型，说明了它不会消耗太多的CPU资源。官方来说，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。

11.Redis为什么要有持久化？

	由于Redis是一个基于内存的数据库，因此数据容易丢失，为了解决数据丢失的问题，于是Redis就设计了持久化。

	两种持久化机制 RDB AOF 目的都是为了尽快能保证数据不丢失，注意是尽可能。

12.RDB、AOF 各自优缺点？
	RDB:
		优点：
			1、只有一个文件 dump.rdb，方便持久化。
			2、容灾性好，一个文件可以保存到安全的磁盘。
			3、比AOF启动快。
		缺点：
			数据安全性低，容易丢失。
	AOF：
		优点：
			1、提供了三种持久化机制，数据相对安全。
		缺点：
			1、AOF 文件比 RDB 文件大，且恢复速度慢。
			2、数据集大的时候，比 rdb 启动效率低很多（执行命令load进内存）。
